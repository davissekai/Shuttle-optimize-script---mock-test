# improved_hybrid_greedy_ga.py

import random
import numpy as np
import copy

# 1. Define the stops and distances for the KNUST campus shuttle route.
stops = ['MG', 'LIB', 'ENG', 'HA', 'HB']
distances = {
    ('MG', 'LIB'): 1.0, ('LIB', 'MG'): 1.0,
    ('MG', 'ENG'): 1.5, ('ENG', 'MG'): 1.5,
    ('LIB', 'ENG'): 0.8, ('ENG', 'LIB'): 0.8,
    ('LIB', 'HA'): 1.2, ('HA', 'LIB'): 1.2,
    ('ENG', 'HB'): 1.0, ('HB', 'ENG'): 1.0,
    ('HA', 'HB'): 0.5, ('HB', 'HA'): 0.5,
    ('HA', 'MG'): 2.0, ('MG', 'HA'): 2.0,
    ('HB', 'MG'): 1.8, ('MG', 'HB'): 1.8,
    ('ENG', 'HA'): 1.1, ('HA', 'ENG'): 1.1,
    ('LIB', 'HB'): 1.2 + 0.5 + 2.0, ('HB', 'LIB'): 1.2 + 0.5 + 2.0, # LIB-HA-HB-MG (shortest path)
}

# Fuel efficiency and emission factor
fuel_efficiency = 3.0  # km/L
emission_factor = 2.68  # kg CO2/L

# GA parameters
population_size = 100
generations = 1000
early_rate = 0.2
late_rate = 0.05
early_generations = 500
elitism_size = int(0.1 * population_size)
distance_threshold = 5.5 # Threshold for eliminating longer routes

# --- Helper Functions ---

def calculate_distance(route):
    """
    Calculates the total distance of a given route.

    Args:
        route (list): A list of stop names representing the order of travel,
                      starting and ending with 'MG'.

    Returns:
        float: The total distance of the route in kilometers.
    """
    total_distance = 0
    for i in range(len(route) - 1):
        stop1 = route[i]
        stop2 = route[i + 1]
        if (stop1, stop2) in distances:
            total_distance += distances[(stop1, stop2)]
        elif (stop2, stop1) in distances:
            total_distance += distances[(stop2, stop1)]
        else:
            # This should ideally not happen given our distance matrix
            return float('inf')
    return total_distance

def calculate_emissions(distance):
    """
    Calculates the CO2 emissions for a given travel distance.

    Args:
        distance (float): The total distance traveled in kilometers.

    Returns:
        float: The total CO2 emissions in kg CO2e.
    """
    fuel_used = distance / fuel_efficiency
    emissions = fuel_used * emission_factor
    return emissions

def generate_random_route():
    """
    Generates a random valid route starting and ending at 'MG'
    and visiting all other stops exactly once.

    Returns:
        list: A randomly generated route.
    """
    other_stops = copy.copy(stops)
    other_stops.remove('MG')
    random.shuffle(other_stops)
    return ['MG'] + other_stops + ['MG']

# --- Greedy Heuristic ---

def greedy_heuristic():
    """
    Generates an initial route using a greedy approach:
    starting from 'MG', always visit the nearest unvisited stop.

    Returns:
        list: The route generated by the greedy heuristic.
    """
    current_stop = 'MG'
    unvisited_stops = copy.copy(stops)
    unvisited_stops.remove('MG')
    greedy_route = ['MG']

    while unvisited_stops:
        nearest_stop = None
        min_distance = float('inf')
        for next_stop in unvisited_stops:
            if (current_stop, next_stop) in distances:
                dist = distances[(current_stop, next_stop)]
            elif (next_stop, current_stop) in distances:
                dist = distances[(next_stop, current_stop)]
            else:
                # Fallback to a large value if direct distance is not available
                # In a real scenario, we might need a more robust way to handle this
                dist = float('inf')

            if dist < min_distance:
                min_distance = dist
                nearest_stop = next_stop

        if nearest_stop:
            greedy_route.append(nearest_stop)
            unvisited_stops.remove(nearest_stop)
            current_stop = nearest_stop
        else:
            # Break if no nearest stop is found (should not happen here)
            break

    greedy_route.append('MG')
    return greedy_route

# --- Genetic Algorithm Functions ---

def evaluate_fitness(population):
    """
    Evaluates the fitness of each route in the population based on its distance.

    Args:
        population (list): A list of routes.

    Returns:
        list: A list of tuples, where each tuple contains (fitness_score, route).
              Lower distance means a higher fitness (lower score).
    """
    fitness_scores = []
    for route in population:
        distance = calculate_distance(route)
        fitness_scores.append((distance, route))
    return sorted(fitness_scores, key=lambda item: item[0]) # Sort by distance (lower is better)

def tournament_selection(population_fitness, tournament_size=5):
    """
    Selects the best route from a random subset of the population.

    Args:
        population_fitness (list): A list of (fitness_score, route) tuples.
        tournament_size (int): The number of individuals to select for the tournament.

    Returns:
        list: The selected parent route.
    """
    participants = random.sample(population_fitness, tournament_size)
    winner = min(participants, key=lambda item: item[0])
    return winner[1]

def ordered_crossover(parent1, parent2):
    """
    Performs ordered crossover (OX) between two parent routes.

    Args:
        parent1 (list): The first parent route.
        parent2 (list): The second parent route.

    Returns:
        list: The offspring route.
    """
    # Ensure we don't cross the start and end 'MG'
    stops1 = parent1[1:-1]
    stops2 = parent2[1:-1]
    n = len(stops1)
    if n < 2:
        return ['MG'] + stops1 + ['MG'] # Not enough stops to crossover

    start = random.randint(0, n - 2)
    end = random.randint(start + 1, n - 1)

    offspring_middle = stops1[start:end + 1]
    offspring = ['MG'] + offspring_middle

    p2_remaining = [stop for stop in stops2 if stop not in offspring_middle]

    # Fill in the remaining slots in the offspring with stops from parent2
    current_index = len(offspring) - 1
    p2_index = 0
    while len(offspring) < n + 1:
        offspring.insert(current_index + 1, p2_remaining[p2_index])
        current_index += 1
        p2_index += 1

    offspring.append('MG')
    return offspring

def mutate(route, mutation_rate):
    """
    Performs a random swap of two stops in a route (excluding the start and end 'MG').

    Args:
        route (list): The route to mutate.
        mutation_rate (float): The probability of mutation occurring.

    Returns:
        list: The mutated route.
    """
    mutated_route = copy.deepcopy(route)
    if random.random() < mutation_rate:
        # Select two indices to swap, ensuring they are not the start or end 'MG'
        indices = list(range(1, len(mutated_route) - 1))
        if len(indices) >= 2:
            i, j = random.sample(indices, 2)
            mutated_route[i], mutated_route[j] = mutated_route[j], mutated_route[i]
    return mutated_route

# --- 2-opt Local Search ---

def two_opt(route, iterations=5): # Added iterations parameter
    """
    Applies the 2-opt local search algorithm to improve a given route,
    repeating the process multiple times.

    Args:
        route (list): The route to optimize.
        iterations (int): The number of times to repeat the 2-opt process.

    Returns:
        list: The optimized route.
    """
    best_route = copy.deepcopy(route)
    for _ in range(iterations): # Repeat the entire 2-opt process
        improved = True
        while improved:
            improved = False
            for i in range(1, len(best_route) - 2):
                for k in range(i + 1, len(best_route) - 1):
                    new_route = copy.deepcopy(best_route)
                    new_route[i:k+1] = reversed(new_route[i:k+1])
                    if calculate_distance(new_route) < calculate_distance(best_route):
                        best_route = new_route
                        improved = True
            if not improved:
                break
    return best_route

# --- Main GA Loop ---

# 1. Initialize population
initial_population = [greedy_heuristic()] + [generate_random_route() for _ in range(population_size - 1)]

population = initial_population

# Track the best route found so far
best_fitness_ga = float('inf')
best_route_ga = None

for generation in range(generations):
    # 2. Evaluate fitness
    fitness_scores = evaluate_fitness(population)
    current_best_distance = fitness_scores[0][0]
    if current_best_distance < best_fitness_ga:
        best_fitness_ga = current_best_distance
        best_route_ga = fitness_scores[0][1]
        best_emissions_ga = calculate_emissions(best_fitness_ga)
        print(f"Generation {generation + 1}: Best distance (GA) = {best_fitness_ga:.2f} km, Emissions = {best_emissions_ga:.2f} kg CO2e")

    # 3. Selection
    next_generation = []
    for _ in range(population_size - elitism_size):
        parent1 = tournament_selection(fitness_scores)
        parent2 = tournament_selection(fitness_scores)

        # 4. Ordered Crossover with adaptive rate
        if generation < early_generations:
            crossover_rate = early_rate
        else:
            crossover_rate = late_rate

        if random.random() < crossover_rate:
            offspring = ordered_crossover(parent1, parent2)
        else:
            offspring = copy.deepcopy(random.choice([parent1, parent2])) # No crossover

        # 5. Mutation with adaptive rate
        if generation < early_generations:
            mutation_rate = early_rate
        else:
            mutation_rate = late_rate
        mutated_offspring = mutate(offspring, mutation_rate)
        next_generation.append(mutated_offspring)

    # 6. Elitism: Keep the best individuals
    elites = [route for _, route in fitness_scores[:elitism_size]]
    next_generation.extend(elites)

    # 7. Elimination of long routes
    next_generation = [route for route in next_generation if calculate_distance(route) <= distance_threshold]

    # Ensure the next generation size remains consistent
    while len(next_generation) < population_size:
        next_generation.append(generate_random_route())

    population = next_generation

# --- Apply 2-opt Local Search to the best GA route ---
optimized_route = two_opt(best_route_ga, iterations=5) # Increased iterations
final_distance = calculate_distance(optimized_route)
final_emissions = calculate_emissions(final_distance)

# --- Output the Results ---
print("\n--- Final Results (Improved Hybrid Greedy + GA + 2-opt) ---")
print("Optimized Route (after 2-opt):", optimized_route)
print("Distance:", f"{final_distance:.2f} km")
print("Emissions:", f"{final_emissions:.2f} kg CO2e/loop")